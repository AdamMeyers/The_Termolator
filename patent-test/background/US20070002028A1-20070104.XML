<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE us-patent-application SYSTEM "us-patent-application-v42-2006-08-23.dtd" [ ]>
<us-patent-application lang="EN" dtd-version="v4.2 2006-08-23" file="US20070002028A1-20070104.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20061221" date-publ="20070104">
<us-bibliographic-data-application lang="EN" country="US">
<publication-reference>
<document-id>
<country>US</country>
<doc-number>20070002028</doc-number>
<kind>A1</kind>
<date>20070104</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>11468956</doc-number>
<date>20060831</date>
</document-id>
</application-reference>
<us-application-series-code>11</us-application-series-code>
<classifications-ipcr>
<classification-ipcr>
<ipc-version-indicator><date>20060101</date></ipc-version-indicator>
<classification-level>A</classification-level>
<section>G</section>
<class>09</class>
<subclass>G</subclass>
<main-group>5</main-group>
<subgroup>00</subgroup>
<symbol-position>F</symbol-position>
<classification-value>I</classification-value>
<action-date><date>20070104</date></action-date>
<generating-office><country>US</country></generating-office>
<classification-status>B</classification-status>
<classification-data-source>H</classification-data-source>
</classification-ipcr>
</classifications-ipcr>
<classification-national>
<country>US</country>
<main-classification>345173000</main-classification>
</classification-national>
<invention-title id="d0e102">Passive Touch System And Method Of Detecting User Input</invention-title>
<us-related-documents>
<division>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10995377</doc-number>
<date>20041124</date>
</document-id>
<parent-status>PENDING</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>11468956</doc-number>
<kind>A1</kind>
<date>20060831</date>
</document-id>
</child-doc>
</relation>
</division>
<division>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>10408671</doc-number>
<date>20030408</date>
</document-id>
<parent-status>ABANDONED</parent-status>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>10995377</doc-number>
<date>20041124</date>
</document-id>
</child-doc>
</relation>
</division>
<continuation>
<relation>
<parent-doc>
<document-id>
<country>US</country>
<doc-number>09610481</doc-number>
<date>20000705</date>
</document-id>
<parent-status>GRANTED</parent-status>
<parent-grant-document>
<document-id>
<country>US</country>
<doc-number>6803906</doc-number>
</document-id>
</parent-grant-document>
</parent-doc>
<child-doc>
<document-id>
<country>US</country>
<doc-number>10408671</doc-number>
<date>20030408</date>
</document-id>
</child-doc>
</relation>
</continuation>
</us-related-documents>
<parties>
<applicants>
<applicant sequence="00" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Morrison</last-name>
<first-name>Gerald</first-name>
<address>
<address-1>736 Arbour Lake Drive NW</address-1>
<city>Calgary</city>
<state>AB</state>
<postcode>T3G 4C6</postcode>
<country>CA</country>
</address>
</addressbook>
<nationality>
<country>CA</country>
</nationality>
<residence>
<country>CA</country>
</residence>
</applicant>
<applicant sequence="01" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Singh</last-name>
<first-name>Manvinder</first-name>
<address>
<address-1>902 Harris Place NW</address-1>
<city>Calgary</city>
<state>AB</state>
<postcode>T3B 2V4</postcode>
<country>CA</country>
</address>
</addressbook>
<nationality>
<country>CA</country>
</nationality>
<residence>
<country>CA</country>
</residence>
</applicant>
</applicants>
<correspondence-address>
<addressbook>
<name>PATENT ADMINISTRATOR;KATTEN MUCHIN ROSENMAN LLP</name>
<address>
<address-1>1025 THOMAS JEFFERSON STREET, N.W.</address-1>
<address-2>EAST LOBBY: SUITE 700</address-2>
<city>WASHINGTON</city>
<state>DC</state>
<postcode>20007-5201</postcode>
<country>US</country>
</address>
</addressbook>
</correspondence-address>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>SMART TECHNOLOGIES, INC.</orgname>
<role>03</role>
<address>
<address-1>1207 - 11 Avenue SW, 3rd Floor, Connaught Building</address-1>
<city>Calgary</city>
<state>AB</state>
<country>CA</country>
</address>
</addressbook>
</assignee>
</assignees>
</us-bibliographic-data-application>
<abstract id="abstract">
<p id="p-0001" num="0000">A passive touch system includes a passive touch surface and at least two cameras associated with the touch surface. The at least two cameras acquire images of the touch surface from different locations and have overlapping fields of view. A processor receives and processes images acquired by the at least two cameras to detect the existence of a pointer therein and to determine the location of the pointer relative to the touch surface. Actual pointer contact with the touch surface and pointer hover above the touch surface can be determined. </p>
</abstract>
<drawings id="DRAWINGS">
<figure id="figure-D00000" num="00000">
<img id="EMI-D00000" he="103.63mm" wi="116.52mm" file="US20070002028A1-20070104-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00001" num="00001">
<img id="EMI-D00001" he="176.45mm" wi="158.07mm" file="US20070002028A1-20070104-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00002" num="00002">
<img id="EMI-D00002" he="252.48mm" wi="150.03mm" file="US20070002028A1-20070104-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00003" num="00003">
<img id="EMI-D00003" he="248.50mm" wi="178.22mm" file="US20070002028A1-20070104-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00004" num="00004">
<img id="EMI-D00004" he="258.32mm" wi="169.08mm" file="US20070002028A1-20070104-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00005" num="00005">
<img id="EMI-D00005" he="256.20mm" wi="169.84mm" file="US20070002028A1-20070104-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00006" num="00006">
<img id="EMI-D00006" he="260.94mm" wi="183.73mm" file="US20070002028A1-20070104-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00007" num="00007">
<img id="EMI-D00007" he="239.35mm" wi="147.91mm" file="US20070002028A1-20070104-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00008" num="00008">
<img id="EMI-D00008" he="233.43mm" wi="126.66mm" file="US20070002028A1-20070104-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00009" num="00009">
<img id="EMI-D00009" he="245.62mm" wi="166.54mm" file="US20070002028A1-20070104-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00010" num="00010">
<img id="EMI-D00010" he="255.78mm" wi="180.09mm" file="US20070002028A1-20070104-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00011" num="00011">
<img id="EMI-D00011" he="228.01mm" wi="145.71mm" file="US20070002028A1-20070104-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00012" num="00012">
<img id="EMI-D00012" he="215.56mm" wi="169.84mm" file="US20070002028A1-20070104-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="figure-D00013" num="00013">
<img id="EMI-D00013" he="232.75mm" wi="140.63mm" file="US20070002028A1-20070104-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?>
<p id="p-0002" num="0001"> This application is a divisional of U.S. patent application Ser. No. 10/995,377, filed Nov. 24, 2004, which is a divisional of U.S. patent application Ser. No. 10/408,671, filed Apr. 8, 2003 (now abandoned), which is a continuation of U.S. patent application Ser. No. 09/610,481, filed Jul. 5, 2000, now U.S. Pat. No. 6,803,906, issued Oct. 12, 2004, the contents of each being incorporated herein by reference.</p>
<?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?>
<?summary-of-invention description="Summary of Invention" end="lead"?>
<heading level="2" id="h-0001">FIELD OF THE INVENTION </heading>
<p id="p-0003" num="0002"> The present invention relates generally to input devices and in particular to a passive touch system and method of detecting user input. </p>
<heading level="2" id="h-0002">BACKGROUND OF THE INVENTION </heading>
<p id="p-0004" num="0003"> Touch systems are well known in the art and typically include a touch screen having a touch surface on which contacts are made using a pointer in order to generate user input. Pointer contacts with the touch surface are detected and are used to generate corresponding output depending on areas of the contact surface where the contacts are made. There are basically two general types of touch systems available and they can be broadly classified as &#x201c;active&#x201d; touch systems and &#x201c;passive&#x201d; touch systems. </p>
<p id="p-0005" num="0004"> Active touch systems allow a user to generate user input by contacting the touch surface with a special pointer that usually requires some form of on-board power source, typically batteries. The special pointer emits signals such as infrared light, visible light, ultrasonic frequencies, electromagnetic frequencies, etc. that activate the touch surface. </p>
<p id="p-0006" num="0005"> Passive touch systems allow a user to generate user input by contacting the touch surface with a passive pointer and do not require the use of a special pointer in order to activate the touch surface. A passive pointer can be a finger, a cylinder of some material, or any suitable object that can be used to contact some predetermined area of interest on the touch surface. </p>
<p id="p-0007" num="0006"> Passive touch systems provide advantages over active touch systems in that any suitable pointing device, including a user's finger, can be used as a pointer to contact the touch surface. As a result, user input can easily be generated. Also, since special active pointers are not necessary in passive touch systems, battery power levels and/or pointer damage, theft, or misplacement are of no concern to users. </p>
<p id="p-0008" num="0007"> Passive touch systems have a number of applications relating to computer operation and video display. For example, in one interactive application, as is disclosed in U.S. Pat. No. 5,448,263 to Martin, assigned to the assignee of the present invention, the passive touch system is coupled to a computer and the computer display is projected onto the touch surface of the touch screen. The coordinates representing specific locations on the touch surface are mapped to the computer display. When a user contacts the touch surface, the coordinates of the contact are fed back to the computer and mapped to the computer display thereby allowing the user to operate the computer in a manner similar to using a computer mouse simply by contacting the touch surface. Furthermore, the coordinates fed back to the computer can be recorded in an application and redisplayed at a later time. Recording contact coordinates is typically done when it is desired to record information written or drawn on the touch surface by the user. </p>
<p id="p-0009" num="0008"> The resolution of a passive touch screen determines if the touch system is suitable for recording information written or drawn on the touch screen or only useful for selecting areas on the touch screen mapped to large regions on the computer or video display in order to manipulate the computer or video display. Resolution is typically measured in dots per inch (DPI). The DPI is related to the size of the touch screen and the sampling ability of the touch system hardware and software used to detect contacts on the touch surface. </p>
<p id="p-0010" num="0009"> Low-resolution passive touch screens only have enough DPI to detect contacts on the touch surface within a large group of pixels displayed by the computer or video system. Therefore, these low-resolution passive touch screens are useful only for manipulating the computer or video display. </p>
<p id="p-0011" num="0010"> On the other hand, high-resolution passive touch screens have sufficient DPI to detect contacts that are proportional to a small number of pixels or sub-pixels of the computer or video display. However, a requirement for high-resolution touch screens is the ability to detect when the pointer is in contact with the touch surface. This is necessary for writing, drawing, mouse-click operations, etc. Without the ability to detect pointer contact with the touch screen, writing and drawing would be one continues operation, and mouse clicks would not be possible thereby making computer display manipulation impossible. A secondary requirement is the ability to detect when the pointer is &#x201c;hovering&#x201d; above the touch surface. Although not required for writing or drawing, today's computer operating systems are increasingly using hover information to manipulate computer or video displays or pop-up information boxes. </p>
<p id="p-0012" num="0011"> Passive touch screens are typically either of the analog resistive type, Surface Acoustic Wave (SAW) type or capacitive type. Unfortunately, these touch screens suffer from a number of problems or shortcomings as will be described. </p>
<p id="p-0013" num="0012"> Analog resistive touch screens typically have a high-resolution. Depending on the complexity of the touch system, the resolution of the touch screen can produce 4096&#xd7;4096 DPI or higher. Analog resistive touch screens are constructed using two flexible sheets that are coated with a resistive material and arranged as a sandwich. The sheets do not come into contact with each other until a contact has been made. The sheets are typically kept separated by insulating microdots or by an insulating air space. The sheets are constructed from ITO, which is mostly transparent. Thus, the touch screen introduces some image distortion but very little parallax. </p>
<p id="p-0014" num="0013"> During operation of an analog resistive passive touch screen, a uniform voltage gradient is applied in one direction along a first of the sheets. The second sheet measures the voltage along the first sheet when the two sheets contact one another as a result of a contact made on the touch surface. Since the voltage gradient of the first sheet can be translated to the distance along the first sheet, the measured voltage is proportional to the position of the contact on the touch surface. When a contact coordinate on the first sheet is acquired, the uniform voltage gradient is then applied to the second sheet and the first sheet measures the voltage along the second sheet. The voltage gradient of the second sheet is proportional to the distance along the second sheet. These two contact coordinates represent the X-Y position of the contact on the touch surface in a Cartesian coordinate system. </p>
<p id="p-0015" num="0014"> Since mechanical pressure is required to bring both sheets into contact, analog resistive touch screens can only detect contact when there is sufficient pressure to bring the two sheets together. Analog resistive passive touch screens cannot sense when a pointer is hovering over the touch surface. Therefore, contact events and positions can only be detected when actual contacts are made with the touch surface. </p>
<p id="p-0016" num="0015"> Surface Acoustic Wave (SAW) touch screens typically provide for medium resolution and are not suitable for recording good quality writing. SAW touch screens employ transducers on the borders of a glass surface to vibrate the glass and produce acoustic waves that ripple over the glass surface. When a contact is made on the glass surface, the waves reflect back and the contact position is determined from the signature of the reflected waves. </p>
<p id="p-0017" num="0016"> Unfortunately, SAW touch screens exhibit noticeable parallax due to the thickness of the vibrating glass which is placed over the surface of the video or computer display. Also, contact events and positions can only be detected when actual contacts are made with the glass surface. Furthermore, SAW touch screens do not scale beyond a few feet diagonal. </p>
<p id="p-0018" num="0017"> Capacitive touch screens provide for low resolution because contacts can only be determined in large areas (approximately &#xbd;&#x2033;&#xd7;&#xbd;&#x2033;). As a result, capacitive touch screens cannot be used for recording writing or drawing and are suitable for selecting areas on the touch screen corresponding to computer generated buttons displayed on the video or computer display. These touch screens also suffer disadvantages in that they are sensitive to temperature and humidity. Similar to analog resistive touch screens and SAW touch screens, capacitive touch screens can also only detect contact events and positions when actual contacts are made with the touch surface. </p>
<p id="p-0019" num="0018"> Scalability of passive touch screens is important since the demand for larger electronic digitizers is increasing. Where digitizers were once small desktop appliances, today they have found there way onto electronic whiteboarding applications. The need to build a passive touch sensitive &#x201c;wall&#x201d; has become a requirement for new touch screen applications. Existing passive touch screens of the types discussed above are all limited in the maximum size where they are still functional. </p>
<p id="p-0020" num="0019"> As will be appreciated, improvements to passive touch systems are desired. It is therefore an object of the present invention to provide a novel passive touch system and method of detecting user input. </p>
<heading level="2" id="h-0003">SUMMARY OF THE INVENTION </heading>
<p id="p-0021" num="0020"> According to one aspect of the present invention there is provided a passive touch system comprising: </p>
<p id="p-0022" num="0021"> a passive touch surface; </p>
<p id="p-0023" num="0022"> at least two cameras associated with said touch surface, said at least two cameras acquiring images of said touch surface from different locations and having overlapping fields of view; and </p>
<p id="p-0024" num="0023"> a processor receiving and processing images acquired by said at least two cameras to detect the existence of a pointer therein and to determine the location of said pointer relative to said touch surface. </p>
<p id="p-0025" num="0024"> In a preferred embodiment, the at least two cameras are two-dimensional image sensor and lens assemblies having fields of view looking along the plane of the touch surface. The processor determines the location of the pointer relative to the touch screen using triangulation. The processor also determines when the pointer is in contact with the touch surface and when the pointer is hovering above the touch surface. </p>
<p id="p-0026" num="0025"> In one embodiment, the processor selects pixel subsets of images acquired by the image sensor and lens assemblies and processes the pixel subsets to determine the existence of the pointer. The processor includes a digital signal processor associated with each image sensor and lens assembly and a master digital signal processor in communication with the digital signal processors. The digital signal processors associated with each image sensor and lens assembly select the pixel subsets and process the pixel subsets to determine the existence of the pointer. The master digital signal processor receives pixel characteristic data from the digital signal processors and triangulates the pixel characteristic data to determine the location of the pointer relative to the touch surface. </p>
<p id="p-0027" num="0026"> According to another aspect of the present invention there is provided a method of detecting the position of a pointer relative to a passive touch surface comprising the steps of: </p>
<p id="p-0028" num="0027"> acquiring images of said touch surface from different locations using cameras having overlapping fields of view; and </p>
<p id="p-0029" num="0028"> processing said images to detect the existence of a pointer therein and to determine the location of said pointer relative to said touch surface. </p>
<p id="p-0030" num="0029"> The present invention provides advantages in that the passive touch system is of high resolution and allows actual pointer contacts with the touch surface as well as pointer hovers above the touch surface to be detected and corresponding output generated. Also, the present passive touch system provides advantages in that it does not suffer from parallax, image distortion, pointer position restrictions, image projection and scalability problems that are associated with prior art passive touch systems.</p>
<?summary-of-invention description="Summary of Invention" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<heading level="2" id="h-0004">BRIEF DESCRIPTION OF THE DRAWINGS </heading>
<p id="p-0031" num="0030"> An embodiment of the present invention will now be described more fully with reference to the accompanying drawings in which: </p>
<p id="p-0032" num="0031"> <figref idref="DRAWINGS">FIG. 1</figref> is a schematic diagram of a passive touch system in accordance with the present invention; </p>
<p id="p-0033" num="0032"> <figref idref="DRAWINGS">FIG. 2</figref> is an isometric view of a touch screen forming part of the passive touch system of <figref idref="DRAWINGS">FIG. 1</figref>; </p>
<p id="p-0034" num="0033"> <figref idref="DRAWINGS">FIG. 3</figref> is an isometric view of a corner portion of the touch screen of <figref idref="DRAWINGS">FIG. 2</figref>; </p>
<p id="p-0035" num="0034"> <figref idref="DRAWINGS">FIG. 4</figref> is a schematic diagram of a camera assembly forming part of the touch screen of <figref idref="DRAWINGS">FIG. 2</figref>; </p>
<p id="p-0036" num="0035"> <figref idref="DRAWINGS">FIG. 5</figref> is a front elevational view of the touch screen of <figref idref="DRAWINGS">FIG. 2</figref> showing the fields of view of two camera assemblies; </p>
<p id="p-0037" num="0036"> <figref idref="DRAWINGS">FIG. 6</figref> is a schematic diagram of a master controller forming part of the passive touch system of <figref idref="DRAWINGS">FIG. 1</figref>; </p>
<p id="p-0038" num="0037"> <figref idref="DRAWINGS">FIG. 7</figref> is case diagram showing functions executed by the camera assemblies; </p>
<p id="p-0039" num="0038"> <figref idref="DRAWINGS">FIG. 8</figref> is a flowchart showing the steps performed during execution of afindPointerMotion( ) function; </p>
<p id="p-0040" num="0039"> <figref idref="DRAWINGS">FIG. 9</figref> is a flowchart showing the steps performed during execution of an autoSelectThres( ) function; </p>
<p id="p-0041" num="0040"> <figref idref="DRAWINGS">FIG. 10</figref> is a flowchart showing the steps performed during execution of an extractPointer function; </p>
<p id="p-0042" num="0041"> <figref idref="DRAWINGS">FIG. 11</figref> is a flowchart showing the steps performed during execution of a centerOfMass( ) function; </p>
<p id="p-0043" num="0042"> <figref idref="DRAWINGS">FIG. 12</figref> is a flowchart showing the steps performed during execution of a process ROI( ) function: </p>
<p id="p-0044" num="0043"> <figref idref="DRAWINGS">FIG. 13</figref> is a flowchart showing the steps performed during execution of a getHighestRegion( ) function; </p>
<p id="p-0045" num="0044"> <figref idref="DRAWINGS">FIG. 14</figref> shows an acquired image and a pixel subset of the image that is processed; </p>
<p id="p-0046" num="0045"> <figref idref="DRAWINGS">FIG. 15</figref> shows a region of interest within the pixel subset; </p>
<p id="p-0047" num="0046"> <figref idref="DRAWINGS">FIG. 16</figref> shows the triangulation geometry used to calculate a pointer contact position on the touch surface of the touch screen; </p>
<p id="p-0048" num="0047"> <figref idref="DRAWINGS">FIG. 17</figref> shows an image acquired by an image sensor and lens assembly including the pointer and its median line; and </p>
<p id="p-0049" num="0048"> <figref idref="DRAWINGS">FIG. 18</figref> shows pointer contact and pointer hover for different orientations of the pointer.</p>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?detailed-description description="Detailed Description" end="lead"?>
<heading level="2" id="h-0005">DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT </heading>
<p id="p-0050" num="0049"> Turning now to <figref idref="DRAWINGS">FIG. 1</figref>, a passive touch system in accordance with the present invention is shown and is generally indicated to by reference numeral <b>50</b>. As can be seen, passive touch system <b>50</b> includes a touch screen <b>52</b> coupled to a master controller <b>54</b>. Master controller <b>54</b> is also coupled to a computer <b>56</b>. Computer <b>56</b> executes one or more application programs and provides display output that is projected onto the touch screen <b>52</b> via a projector <b>58</b>. The touch screen <b>52</b>, master controller <b>54</b>, computer <b>56</b> and projector <b>58</b> form a closed-loop so that user contacts with the touch screen <b>52</b> can be recorded as writing or drawing or used to control execution of application programs executed by the computer <b>56</b>. </p>
<p id="p-0051" num="0050"> FIGS. <b>2</b> to <b>4</b> better illustrate the touch screen <b>52</b>. Touch screen <b>52</b> includes a touch surface <b>60</b> bordered by a frame <b>62</b>. Touch surface <b>60</b> is passive and is in the form of a rectangular planar sheet of material. Camera subsystems are associated with each corner of the touch screen <b>52</b>. Each camera subsystem includes a camera assembly <b>63</b> mounted adjacent a different corner of the touch screen <b>52</b> by a frame assembly <b>64</b>. Each frame assembly <b>64</b> includes an angled support plate <b>66</b> on which the camera assembly <b>63</b> is mounted. Supporting frame elements <b>70</b> and <b>72</b> are mounted on the plate <b>66</b> by posts <b>74</b> and secure the plate <b>66</b> to the frame <b>62</b>. </p>
<p id="p-0052" num="0051"> Each camera assembly <b>63</b>, in this embodiment, includes a camera in the form of a two-dimensional CMOS camera image sensor and associated lens assembly <b>80</b>, a first-in-first-out (FIFO) buffer <b>82</b> coupled to the image sensor and lens assembly <b>80</b> by a data bus and a digital signal processor (DSP) <b>84</b> coupled to the FIFO <b>82</b> by a data bus and to the image sensor and lens assembly <b>80</b> by a control bus. A boot EPROM <b>86</b> and a power supply subsystem <b>88</b> are also included. </p>
<p id="p-0053" num="0052"> In the present embodiment, the CMOS camera image sensor is a Photobit PB300 image sensor configured for a 20&#xd7;640 pixel subarray that can be operated to capture image frames at rates in excess of 200 frames per second. The FIFO buffer <b>82</b> is manufactured by Cypress under part number CY7C4211V and the DSP <b>84</b> is manufactured by Analog Devices under part number ADSP2185M. </p>
<p id="p-0054" num="0053"> The DSP <b>84</b> provides control information to the image sensor and lens assembly <b>80</b> via the control bus. The control information allows the DSP <b>84</b> to control parameters of the image sensor and lens assembly <b>80</b> such as exposure, gain, array configuration, reset and initialization. The DSP <b>84</b> also provides clock signals to the image sensor and lens assembly <b>80</b> to control the frame rate of the image sensor and lens assembly <b>80</b>. </p>
<p id="p-0055" num="0054"> As shown in <figref idref="DRAWINGS">FIG. 5</figref>, each image sensor and lens assembly <b>80</b> has a 55&#xb0; field of view. The angle of the plate <b>66</b> is selected so that the field of view of each image and lens assembly <b>80</b> includes at least the majority of a different peripheral edge of the touch surface <b>60</b>. In this way, the entire touch surface <b>60</b> is within the fields of view of the image sensor and lens assemblies <b>80</b>. </p>
<p id="p-0056" num="0055"> Master controller <b>54</b> is best illustrated in <figref idref="DRAWINGS">FIG. 6</figref> and includes a DSP <b>90</b>, a boot EPROM <b>92</b>, a serial line driver <b>94</b> and a power supply subsystem <b>95</b>. The DSP <b>90</b> communicates with the DSPs <b>84</b> of the camera assemblies <b>63</b> over a data bus through a serial port <b>96</b> and communicates with the computer <b>56</b> over a data bus through a serial port <b>98</b> and the serial line driver <b>94</b>. In this embodiment, the DSP <b>90</b> is also manufactured by Analog Devices under part number ADSP2185M. The serial line driver <b>94</b> is manufactured by Analog Devices under part number ADM222. </p>
<p id="p-0057" num="0056"> The master controller <b>54</b> and each camera assembly <b>63</b> follow a communication protocol that enables bi-directional communications via a common serial cable similar to a universal serial bus (USB). The transmission bandwidth is divided into thirty-two (32) 16-bit channels. Of the thirty-two channels, five (5) channels are assigned to each of the DSPs <b>84</b> in the camera assemblies <b>63</b> and to the DSP <b>90</b> in the master controller <b>54</b> and the remaining seven (7) channels are unused. The master controller <b>54</b> monitors the twenty (20) channels assigned to the camera assembly DSPs <b>84</b> while the DSPs <b>84</b> in the camera subsystems <b>63</b> monitor the five (5) channels assigned to the master controller DSP <b>90</b>. Communications between the master controller <b>54</b> and the camera assemblies <b>63</b> are performed as background processes in response to interrupts. </p>
<p id="p-0058" num="0057"> The general operation of the passive touch system <b>50</b> will now be described. Each camera assembly <b>63</b> acquires images of the touch surface <b>60</b> within the field of view of its image sensor and lens assembly <b>80</b> at the frame rate established by the DSP clock signals and processes the images to determine if a pointer is in the acquired images. If a pointer is in the acquired images, the images are further processed to determine characteristics of the pointer contacting or hovering above the touch surface <b>60</b>. Pointer characteristics are then converted into pointer information packets (PIPs) and the PIPs are queued for transmission to the master controller <b>54</b>. The camera assemblies <b>63</b> also receive and respond to diagnostic PIPs generated by the master controller <b>54</b>. </p>
<p id="p-0059" num="0058"> The master controller <b>54</b> polls the camera assemblies <b>63</b> at a set frequency (in this embodiment 70 times per second) for PIPs and triangulates pointer characteristics in the PIPs to determine pointer position data. The master controller <b>54</b> in turn transmits pointer position data and/or status information to the personal computer <b>56</b>. In this manner, the pointer position data transmitted to the personal computer <b>56</b> can be recorded as writing or drawing or can be used to control execution of application programs executed by the computer <b>56</b>. The computer <b>56</b> also updates the display output conveyed to the projector <b>58</b> so that information projected onto the touch surface <b>60</b> reflects the pointer activity. </p>
<p id="p-0060" num="0059"> The master controller <b>54</b> also receives commands from the personal computer <b>56</b> and responds accordingly as well as generates and conveys diagnostic PIPs to the camera assemblies <b>63</b>. </p>
<p id="p-0061" num="0060"> Specifics concerning the processing of acquired images and the triangulation of pointer characteristics in PIPs will now be described with particular reference to FIGS. <b>7</b> to <b>13</b>. </p>
<p id="p-0062" num="0061"> Initially, an alignment routine is performed to align the image sensor and lens assemblies <b>80</b>. During the alignment routine, a pointer is held in the approximate center of the touch surface <b>60</b>. Subsets of the pixels of the image sensor and lens assemblies <b>80</b> are then selected until a subset of pixels for each image sensor and lens assembly <b>80</b> is found that captures the pointer and the pointer tip on the touch surface <b>60</b>. This alignment routine allows for a relaxation in mechanical mounting of the image sensor and lens assemblies on the frame assemblies <b>64</b>. The identification of the pointer tip on the touch surface <b>60</b> also gives a calibration that determines the row of pixels of each image sensor and lens assembly <b>80</b> that detects actual contacts made with the touch surface. Knowing these pixel rows allows the difference between pointer hover and pointer contact to be determined. </p>
<p id="p-0063" num="0062"> In this embodiment, since a computer display is projected onto the touch surface <b>60</b>, during the alignment routine several known coordinate locations are also displayed and the user is required to touch these coordinate locations in sequence using the pointer so that the subset of pixels for each of image sensor and lens assembly <b>80</b> includes all of the coordinate locations as well. Calibration data is then stored for reference so that pointer contacts on the touch surface <b>60</b> can be mapped to corresponding areas on the computer display. </p>
<p id="p-0064" num="0063"> As mentioned above, each camera assembly <b>63</b> acquires images of the touch surface <b>60</b> within its field of view. The images are acquired by the image and lens assembly <b>80</b> at intervals in response to the clock signals received from the DSP <b>84</b>. Each image acquired by the image and lens assembly <b>80</b> is sent to the FIFO buffer <b>82</b>. </p>
<p id="p-0065" num="0064"> The DSP <b>84</b> in turn reads each image from the FIFO buffer <b>82</b> and processes the image to determine if a pointer is located in the image and if so, to extract the pointer and related pointer statistical information. To avoid processing significant numbers of pixels containing no useful information, only the subset of the pixels in the image determined during the alignment routine are actually processed as is shown in <figref idref="DRAWINGS">FIG. 14</figref>. </p>
<p id="p-0066" num="0065"> In order to determine if a pointer is located in the image and extract pointer and related pointer statistical information, the DSP <b>84</b> executes a main findPointerMotion( ) function <b>120</b> that calls a number of other functions, namely an autoSelectThres( ) function <b>122</b>, an extractPointer function <b>124</b>, a centerOfMass( ) function <b>126</b>, and a processROI( ) function <b>128</b> (see <figref idref="DRAWINGS">FIG. 7</figref>). The extractPointer( ) function <b>128</b> also calls a getHighestRegion( ) function <b>130</b>. </p>
<p id="p-0067" num="0066"> The findPointerMotion( ) function <b>120</b> is used to extract the pointer from the image. Turning now to <figref idref="DRAWINGS">FIG. 8</figref>, the steps performed during execution of thefindPointerMotion( ) function <b>120</b> is shown. When thefindPointerMotion( ) function is called, a check is made to determine if a previous image iPrev including a pointer exists (step <b>150</b>). If no previous image iPrev exists, center of mass parameters Cx and Cz are assigned zero values (step <b>152</b>). The current image iCurr being processed is then designated as the previous image iPrev (step <b>154</b>) to complete the findPointerMotion( ) function. </p>
<p id="p-0068" num="0067"> At step <b>150</b>, if a previous image iPrev exists, the current image iCurr is subtracted from the previous image iPrev and the absolute value of the difference image iDiff is taken (step <b>156</b>). By forming the difference image iDiff, background features and noise are removed. The autoSelectThres( ) function <b>122</b> is then called to select a threshold value tvalue for the difference image iDiff (step <b>158</b>) based on the histogram of the difference image iDiff. The threshold iThres of the difference image iDiff is then taken (step <b>160</b>) to highlight further the pointer within the current image iCurr. During thresholding a grayscale image is mapped to the binary difference image iDiff. Pixels in the difference image with values equal to or less than the threshold value tvalue are made black while all other pixels are made white. The result is a binary image containing the pointer and some noise both designated by white pixels. </p>
<p id="p-0069" num="0068"> Once the difference image has been thresholded, the extractPointer function <b>124</b> is called (step <b>162</b>) to extract the pointer ptr from the difference image iDiff and ignore the noise. The size of the pointer ptr is then examined to determine if it is greater than a threshold value MIN_PTR_SIZE (step <b>164</b>). </p>
<p id="p-0070" num="0069"> If the size of the pointer is greater than the threshold value MIN_PTR_SIZE, the centerOfMass( ) function <b>126</b> is called (step <b>166</b>) to determine the center of the pointer. Following this, the processROI( ) function <b>128</b> is called (step <b>168</b>) to select a region of interest ROI within the difference image iDiff and extract the pointer from the region of interest. </p>
<p id="p-0071" num="0070"> Once the pointer has been extracted from the region of interest ROI, the size of the extracted pointer is determined (step <b>170</b>). If the pointer size is greater than zero, a medianLine function is called (step <b>172</b>). During execution of the medianLine function, the median line of the pointer (i.e. the pointer location within the region of interest) is calculated using linear least squares. The current image iCurr is then designated as the previous image iPrev to complete the findPointerMotion( ) function. </p>
<p id="p-0072" num="0071"> At step <b>164</b>, if the pointer size is equal to zero, the center of mass parameters Cx and Cz are examined (step <b>174</b>). If both of the center of mass parameters Cx and Cz have values greater zero, the processROI( ) function <b>128</b> is called (step <b>168</b>) to select a region of interest ROI within the difference image iDiff and extract the pointer from the region of interest. At step <b>174</b>, if one or both of the center of mass parameters Cx and Cz have values equal to zero or at step <b>170</b>, if the size of the pointer is less than zero, a no pointer found condition is determined (step <b>176</b>). At this stage, the current image iCurr is designated as a calibration image glRef. The findPointerMotion( ) function then proceeds to step <b>152</b> where the center of mass parameters Cx and Cz are assigned zero values. </p>
<p id="p-0073" num="0072"> As mentioned above, at step <b>158</b>, when the findPointerMotion( ) function <b>120</b> calls the autoSelectThres( ) function <b>122</b>, a threshold value for the difference image iDiff is selected based on the histogram of the difference image so that when the difference image iDiff is thresholded, the pointer is further highlighted from background features and noise. Selection of the threshold value in this manner is more robust than hardcoding the threshold value. </p>
<p id="p-0074" num="0073"> Turning now to <figref idref="DRAWINGS">FIG. 9</figref>, the steps performed during execution of the autoSelectThres( ) function <b>122</b> are illustrated. As can be seen, in order to select the threshold level, a histogram of the difference image iDiff is taken and the number of pixels in each bin of the histogram are counted (step <b>200</b>). The number of pixels in the bin having the highest count is used as a peak parameter and the threshold value is initially assigned a value of one (step <b>202</b>). The number of bins having non-zero counts is then examined to determine if more than eight (<b>8</b>) bins have non-zero counts (step <b>204</b>). If less than eight (<b>8</b>) bins have non-zero counts, the threshold value remains at its initially assigned value and the autoSelectThres( ) function is completed. </p>
<p id="p-0075" num="0074"> At step <b>204</b>, if more than eight (<b>8</b>) bins have non-zero counts, the number of non-zero bins is checked again to determine if an entire difference image is being processed (i.e. the autoSelectThres( ) function was called by the findPointerMotion( ) function <b>120</b>) or if a region of interest ROI within the difference image is being processed (i.e. the autoSelectThres( ) function was called by the processROI( ) function <b>128</b>) (step <b>206</b>). If the entire difference image iDiff is being processed, a threshold minimum parameter (tMin) is set to a value of twelve (12) and a Peak_Div parameter is set to a value of eight (8) (step <b>208</b>). A minimum count parameter minCount is then calculated by dividing the peak parameter determined at step <b>202</b> by the Peak_Div parameter (step <b>210</b>). If a region of interest is being processed, the threshold minimum parameter (tMin) is set to a value of forty (40) and the Peak_Div parameter is set to a value of thirty-two (32) (step <b>212</b>) before proceeding to step <b>210</b>. </p>
<p id="p-0076" num="0075"> Once minCount has been determined, the peak level is checked to determine if it is greater than the threshold minimum tMin (step <b>214</b>). Peak level is the grayscale level that contains the most pixels. In the case of a tie, the grayscale level with the highest numerical value (i.e. the closest to 255) is chosen. If the peak level is greater than the threshold minimum tMin, a startLevel parameter is assigned a value equal to the peak level+1 (step <b>216</b>). At step <b>214</b>, if the peak level is less than the threshold minimum tMin, the startLevel parameter is assigned a value equal to the threshold minimum tMin (step <b>218</b>). </p>
<p id="p-0077" num="0076"> Following step <b>216</b> or <b>218</b>, a loop is entered. During the loop, the levCount for each bin having a bin number between the value of the startLevel parameter and two hundred and fifty-five (255) is examined to determine if it is greater than zero and if it is less than the minCount parameter determined at step <b>210</b> (step <b>220</b>). If the condition is met during the loop, the loop is exited and the threshold value is assigned a value equal to the bin number having the levCount that resulted in the loop being exited+1 (step <b>222</b>). If the condition is not met, the loop is exited after the levCount for bin number <b>255</b> has been checked. </p>
<p id="p-0078" num="0077"> Once the loop has been exited, the threshold value is checked to determine if it is less than the minimum threshold value tMin (step <b>224</b>). If not, a check is again made to determine if an entire difference image is being processed or whether a region of interest ROI is being processed (step <b>226</b>). If the threshold value is less than the minimum threshold value tMin, the threshold value is set equal to the minimum threshold value tMin (step <b>228</b>) before the check is made to determine if an entire difference image is being processed or whether a region of interest is being processed (step <b>226</b>). </p>
<p id="p-0079" num="0078"> At step <b>226</b>, if a difference image iDiff is being processed, the autoSelectThres( ) function is completed. However, if a region of interest is being processed, a parameter p is assigned a value corresponding to the first grayscale level at which 90% or more of the pixels will go black (step <b>230</b>). The parameter p is then compared to the threshold level (step <b>232</b>). If the parameter p is less than the threshold level, the autoSelectThres( ) function is completed. If the parameter p is greater than the threshold level, the threshold value is set to the value of parameter p (step <b>234</b>) and the autoSelectThres( ) function is completed. </p>
<p id="p-0080" num="0079"> As mentioned above, at step <b>162</b> the findPointerMotion( ) function <b>120</b> calls the extractPointer( ) function <b>124</b> to extract the pointer from the binary image and ignore the noise. This is done by selecting the &#x201c;white region&#x201d; in the binary image that is greater than or equal to a certain minimum size and is the highest region (i.e. the largest in the y-axis (20 pixel axis)). Specifically, when the extractPointer( ) function <b>124</b> is called, the extractPointer( ) function calls the getHighestRegion( ) function <b>130</b> (step <b>250</b>). The getHighestRegion( ) function <b>130</b> uses the threshold value and tol parameters to select the appropriate white region szRegion in the thresholded difference image. The toT parameter is used to avoid situations where board surface noise is mistaken as a pointer. <figref idref="DRAWINGS">FIG. 13</figref> shows the steps performed during this function. </p>
<p id="p-0081" num="0080"> Once the white region szRegion has been selected, the white region szRegion is checked to see if it is greater than zero (step <b>252</b>). If not, a no pointer condition is determined (step <b>254</b>). If the white region szRegion is greater than zero, morphological operator of erosion and dilation are used on the white region to reduce further noise (steps <b>256</b> to <b>264</b>) and the extractPointer( ) function is completed. As mentioned above, at step <b>166</b> thefindPointerMotion( ) function <b>120</b> calls the centerOfMass( ) function <b>126</b> to determine the center of the pointer. During this function, the black pixels in the binary image are treated as having a mass of zero (0) and the white pixel are treated as having a mass of one (1). The physics formulae for center-of-mass are used. The equation below gives the center of mass in the x-direction: 
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>x</sub>=sum(<i>X</i><sub>i</sub>)/<i>M</i><?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
 where: 
</p>
<p id="p-0082" num="0081"> X<sub>i </sub>are the x-coordinates of the white pixels in the binary image; and </p>
<p id="p-0083" num="0082"> M is the number of white pixels in the binary image. </p>
<p id="p-0084" num="0083"> Initially, once the centerOfMass( ) function is executed, the center of mass parameters massX, massZ and a mass parameter are assigned zero values (see step <b>300</b> in <figref idref="DRAWINGS">FIG. 11</figref>). A loop is then entered to calculate the center of mass parameters massX and massZ using the above equation and to calculate the mass parameter (step <b>302</b>). </p>
<p id="p-0085" num="0084"> Upon exiting the loop, the mass parameter is checked to determine if its value is greater than zero (step <b>304</b>). If the value of the mass parameter is equal to zero, the center of mass parameters Cx and Cz are assigned values of zero (step <b>306</b>) and the centerOfMass( ) function <b>126</b> is completed. At step <b>304</b>, if the value of the mass parameter is greater than zero, the center of mass coordinates Cx and Cz are calculated (step <b>308</b>) using the equations: 
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>Cx</i>=mass<i>X</i>/mass; and<?in-line-formulae description="In-line Formulae" end="tail"?>
<br/>
<?in-line-formulae description="In-line Formulae" end="lead"?><i>Cz</i>=mass<i>Z</i>/mass.<?in-line-formulae description="In-line Formulae" end="tail"?>
</p>
<p id="p-0086" num="0085"> Once the center of mass coordinates have been calculated, the centerOfMass( ) function <b>126</b> is completed. </p>
<p id="p-0087" num="0086"> As mentioned above, at step <b>168</b> the findPointerMotion( ) function <b>120</b> calls the processROI( ) function <b>128</b> to process the region-of-interest in a manner similar to the findPointerMotion( ) function <b>120</b> except, here the image size is 100&#xd7;20 pixels and a calibration image including only background (i.e. no pointer) is used in place of the previous image. Upon execution of the processROI( ) function <b>128</b>, xLeft and xRight parameters are calculated by subtracting and adding fifty (50) to the center of mass parameter Cx (step <b>350</b>). The value of parameter xLeft is then checked to determine if it is less than one (1) (step <b>352</b>). If the parameter xLeft has a value less than one (1), the parameter xRight is recalculated and the parameter xLeft is assigned a value of one (1) (step <b>354</b>) to define boundaries of the region of interest as shown in <figref idref="DRAWINGS">FIG. 15</figref>. A difference image iDiff of the region of interest is then calculated by subtracting the region of interest of the current image from the region of interest of the calibration image glRef determined at step <b>176</b> of the findPointerMotion( ) function <b>120</b> and taking the absolute value of the difference (step <b>356</b>). </p>
<p id="p-0088" num="0087"> At step <b>352</b>, if the parameter xLeft has a value greater than one (1), the parameter xRight is checked to determine if it has a value greater than <b>640</b> (step <b>358</b>). If the parameter xRight has a value greater than <b>640</b>, the parameter xLeft is recalculated and the parameter xRight is assigned a value of one (1) (step <b>360</b>) to define boundaries of the region of interest. The processROI( ) function <b>128</b> then proceeds to step <b>356</b> to calculate the difference image iDiff of the region of interest. At step <b>358</b>, if the parameter xRight has a value less than <b>640</b>, the processROI( ) function <b>128</b> proceeds directly to step <b>356</b> to calculate the difference image iDiff of the region of interest. </p>
<p id="p-0089" num="0088"> Once the difference image iDiff of the region of interest has been calculated, the autoSelectThres( ) function <b>122</b> is called to select a threshold value for the difference image iDiff of the region of interest (step <b>362</b>) in the manner described above with reference to <figref idref="DRAWINGS">FIG. 9</figref>. The difference image iDiff of the region of interest is then thresholded (step <b>364</b>). Following this, the extractPointer( ) function <b>124</b> is called to extract the pointer from the difference image iDiff of the region of interest (step <b>366</b>) in the manner described above with reference to <figref idref="DRAWINGS">FIG. 10</figref>. </p>
<p id="p-0090" num="0089"> Once the acquired image has been processed in the above manner, a PIP for the acquired image is created by the DSP <b>84</b>. The PIP is a five (<b>5</b>) word packet and has a layout including camera identification, an LRC checksum to ensure data integrity and a valid tag to ensure zero packets are not valid. The valid tag indicates whether the PIP relates to a pointer characteristic packet (<b>10</b>), a diagnostic packet for a specific camera assembly <b>63</b> (<b>01</b>) or a diagnostic packet for all camera assemblies <b>63</b> (<b>11</b>). Table 1 below shows the PIP layout.  
<tables id="TABLE-US-00001" num="1">
<table frame="none" colsep="0" rowsep="0" pgwide="1">
<tgroup align="left" colsep="0" rowsep="0" cols="17">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="14PT" align="center"/>
<colspec colname="3" colwidth="14PT" align="center"/>
<colspec colname="4" colwidth="21PT" align="center"/>
<colspec colname="5" colwidth="21PT" align="center"/>
<colspec colname="6" colwidth="14PT" align="center"/>
<colspec colname="7" colwidth="14PT" align="center"/>
<colspec colname="8" colwidth="14PT" align="center"/>
<colspec colname="9" colwidth="14PT" align="center"/>
<colspec colname="10" colwidth="14PT" align="center"/>
<colspec colname="11" colwidth="14PT" align="center"/>
<colspec colname="12" colwidth="14PT" align="center"/>
<colspec colname="13" colwidth="14PT" align="center"/>
<colspec colname="14" colwidth="14PT" align="center"/>
<colspec colname="15" colwidth="14PT" align="center"/>
<colspec colname="16" colwidth="14PT" align="center"/>
<colspec colname="17" colwidth="14PT" align="center"/>
<thead>
<row>
<entry namest="1" nameend="17" align="center">TABLE 1</entry>
</row>
<row>
<entry/>
</row>
<row>
<entry namest="1" nameend="17" align="center" rowsep="1"/>
</row>
<row>
<entry>Word</entry>
<entry>15</entry>
<entry>14</entry>
<entry>13</entry>
<entry>12</entry>
<entry>11</entry>
<entry>10</entry>
<entry>9</entry>
<entry>8</entry>
<entry>7</entry>
<entry>6</entry>
<entry>5</entry>
<entry>4</entry>
<entry>3</entry>
<entry>2</entry>
<entry>1</entry>
<entry>0</entry>
</row>
<row>
<entry namest="1" nameend="17" align="center" rowsep="1"/>
</row>
</thead>
<tbody valign="top">
<row>
<entry/>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<tbody valign="top">
<row>
<entry>Pointer Characteristics packet (generated by Camera)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="28PT" align="center"/>
<colspec colname="3" colwidth="42PT" align="center"/>
<colspec colname="4" colwidth="168PT" align="center"/>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>Valid</entry>
<entry>Camera #</entry>
<entry>X intercept (at Y0)</entry>
</row>
<row>
<entry/>
<entry>tag</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="126PT" align="center"/>
<colspec colname="3" colwidth="112PT" align="center"/>
<tbody valign="top">
<row>
<entry>1</entry>
<entry>Frame rate</entry>
<entry>intensity/color</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="70PT" align="center"/>
<colspec colname="3" colwidth="168PT" align="center"/>
<tbody valign="top">
<row>
<entry>2</entry>
<entry>Packet #</entry>
<entry>pointer area</entry>
</row>
<row>
<entry>3</entry>
<entry>Unused</entry>
<entry>X intercept (at Y19)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="49PT" align="center"/>
<colspec colname="3" colwidth="77PT" align="center"/>
<colspec colname="4" colwidth="112PT" align="center"/>
<tbody valign="top">
<row>
<entry>4</entry>
<entry>Unused</entry>
<entry>Z position</entry>
<entry>LRC checksum</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="1">
<colspec colname="1" colwidth="259PT" align="center"/>
<tbody valign="top">
<row>
<entry>Diagnostic Packet (generated by Camera or Master)</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="4">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="28PT" align="center"/>
<colspec colname="3" colwidth="42PT" align="center"/>
<colspec colname="4" colwidth="168PT" align="center"/>
<tbody valign="top">
<row>
<entry>0</entry>
<entry>Valid</entry>
<entry>Camera #</entry>
<entry/>
</row>
<row>
<entry/>
<entry>tag</entry>
</row>
<row>
<entry>1</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="70PT" align="center"/>
<colspec colname="3" colwidth="168PT" align="center"/>
<tbody valign="top">
<row>
<entry>2</entry>
<entry>Packet #</entry>
<entry/>
</row>
<row>
<entry>3</entry>
</row>
</tbody>
</tgroup>
<tgroup align="left" colsep="0" rowsep="0" cols="3">
<colspec colname="1" colwidth="21PT" align="center"/>
<colspec colname="2" colwidth="126PT" align="center"/>
<colspec colname="3" colwidth="112PT" align="center"/>
<tbody valign="top">
<row>
<entry>4</entry>
<entry/>
<entry>LRC checksum</entry>
</row>
<row>
<entry namest="1" nameend="3" align="center" rowsep="1"/>
</row>
</tbody>
</tgroup>
</table>
</tables>
</p>
<p id="p-0091" num="0090"> As mentioned above, each camera assembly <b>63</b> acquires and processes an image in the manner described above in response to each clock signal generated by its DSP <b>84</b>. The PIPs created by the DSPs <b>84</b> are only sent to the master controller <b>54</b> when the camera assemblies <b>63</b> are polled by the master controller. The DSPs <b>84</b> create PIPs faster than the master controller <b>54</b> polls the camera assemblies <b>63</b>. PIPs that are not sent to the master controller <b>54</b> are overwritten. </p>
<p id="p-0092" num="0091"> When the master controller <b>54</b> polls the camera assemblies <b>63</b>, frame sync pulses are sent to the camera assemblies <b>63</b> to initiate transmission of the PIPs created by the DSPs <b>84</b>. Upon receipt of a frame sync pulse, each DSP <b>84</b> transmits the PIP to the master controller <b>54</b> over the data bus. The PIPs transmitted to the master controller <b>54</b> are received via the serial port <b>96</b> and auto-buffered into the DSP <b>90</b>. </p>
<p id="p-0093" num="0092"> After the DSP <b>90</b> has polled the camera assemblies <b>63</b> and has received PIPs from each of the camera assemblies, the DSP <b>90</b> processes the PIPs using triangulation to determine the location of the pointer relative to the touch surface <b>60</b> in (x,y) coordinates. Specifically, the PIPs from pairs of camera assemblies <b>63</b> are processed using triangulation. </p>
<p id="p-0094" num="0093"> <figref idref="DRAWINGS">FIG. 16</figref> shows that two angles &#xf8;<sub>1 </sub>and &#xf8;<sub>2 </sub>are needed to triangulate the position (x<sub>0</sub>, y<sub>0</sub>) of the pointer relative to the touch screen <b>60</b>. The PIPs generated by each camera assembly <b>63</b> include a number &#x3b8;&#x2208;[0, sensorResolution&#x2212;1] (see <figref idref="DRAWINGS">FIG. 17</figref>) identifying the median line of the pointer. The sensorResolution, in the case of the Photobit PB300 image sensor, is 640. The equations below relate the angle &#xf8; to the position &#x3b8; taking into account the field-of-view of the image sensor and lens assembly <b>80</b>:  
<maths id="MATH-US-00001" num="1">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <mi>&#x3d5;</mi>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mfrac>
              <mi>&#x3b8;</mi>
              <mi>sensorResolution</mi>
            </mfrac>
            <mo>&#xd7;</mo>
            <msub>
              <mi>F</mi>
              <mi>ov</mi>
            </msub>
          </mrow>
          <mo>-</mo>
          <mi>&#x3b4;</mi>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>1</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <mi>&#x3d5;</mi>
        <mo>=</mo>
        <mrow>
          <mrow>
            <mfrac>
              <mrow>
                <mi>SensorResolution</mi>
                <mo>-</mo>
                <mi>&#x3b8;</mi>
              </mrow>
              <mi>sensorResolution</mi>
            </mfrac>
            <mo>&#xd7;</mo>
            <msub>
              <mi>F</mi>
              <mi>ov</mi>
            </msub>
          </mrow>
          <mo>-</mo>
          <mi>&#x3b4;</mi>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>2</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0095" num="0094"> The above equations subtract away an angle &#x3b4;that allows the image sensor and lens assembly <b>80</b> to have some overlap with the frame <b>62</b>. The overlap with the frame <b>62</b> is desired due to mechanical tolerance issues in the frame assemblies <b>64</b> (i.e. the angle of the plate <b>66</b> can have an error of 1&#xb0; to 2&#xb0;). The angle &#x3b4; is allowed to be negative, meaning that there is no overlap with the frame <b>62</b>, in fact part of the touch surface <b>60</b> along the frame <b>62</b> is missed. Equation 1 or 2 is used to determine &#xf8;, depending on the mounting and/or optical properties of the image sensor and lens assembly <b>80</b>. If the image acquired by the camera assembly <b>63</b> is rotated as a result of the mounting and/or optical properties of the image sensor and lens assembly <b>80</b>, then equation 2 is used. Equation 1 is used otherwise. In the present embodiment, equation 1 is used with the camera assemblies <b>63</b> positioned at the top left and bottom right corners of the touch screen <b>52</b> and equation 2 is used with the camera assemblies <b>63</b> positioned at the bottom left and top right comers of the touch screen <b>52</b>. </p>
<p id="p-0096" num="0095"> As discussed above, equations 1 and 2 allow the pointer median line data included in the PIPs to be converted by the DSP <b>90</b> into an angle &#xf8; with respect to the x-axis. When two such angles are available, the intersection of the median lines extending at these angles from their respective camera assemblies <b>63</b> yields the location of the pointer relative to the touch surface <b>60</b>. </p>
<p id="p-0097" num="0096"> In this embodiment, since the touch screen <b>52</b> includes four camera assemblies <b>63</b>, six pairs of camera assemblies can be used for triangulation. The following discussion describes how a pointer position is determined by triangulation for each pair of the camera assemblies <b>63</b>. </p>
<p id="p-0098" num="0097"> In order to determine a pointer position using the PIPs received from the camera assemblies <b>63</b> along the left side of the touch screen <b>52</b>, the following equations are used to determine the (x<sub>0</sub>, Y<sub>0</sub>) coordinates of the pointer position given the angles &#xf8;<sub>0 </sub>and &#xf8;<sub>1 </sub>for the upper and lower camera assemblies:  
<maths id="MATH-US-00002" num="2">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>x</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mrow>
          <mfrac>
            <mi>h</mi>
            <mi>w</mi>
          </mfrac>
          <mo>&#xd7;</mo>
          <mfrac>
            <mn>1</mn>
            <mrow>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mfrac>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>3</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>y</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <mi>tan</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>&#x3d5;</mi>
                <mn>0</mn>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mrow>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>0</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>1</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>4</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
<br/>
 where: 
</p>
<p id="p-0099" num="0098"> h is the height of the touch screen <b>52</b> i.e. the vertical distance from camera assembly focal point-to-focal point; </p>
<p id="p-0100" num="0099"> w is the width of the touch screen <b>52</b> i.e. the horizontal distance from camera assembly focal point-to-focal point; and </p>
<p id="p-0101" num="0100"> &#xf8;<sub>i </sub>is the angle with respect to the horizontal, measured using camera assembly i and equation 1 or 2. </p>
<p id="p-0102" num="0101"> For the camera assemblies <b>63</b> along on the right side of the touch screen <b>52</b>, the following equations are used to determine the (x<sub>0</sub>, y<sub>0</sub>) coordinates of the pointer position given the angles &#xf8;<sub>2 </sub>and &#xf8;<sub>3 </sub>for the upper and lower camera assemblies:  
<maths id="MATH-US-00003" num="3">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>x</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
            <mfrac>
              <mi>h</mi>
              <mi>w</mi>
            </mfrac>
            <mo>&#xd7;</mo>
            <mfrac>
              <mn>1</mn>
              <mrow>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>+</mo>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>3</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mfrac>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>5</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>y</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mfrac>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>2</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mrow>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>3</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mfrac>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>6</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0103" num="0102"> The similarity between equations 3 and 5, i.e. equation 5=1&#x2212;equation 3 once &#xf8;<sub>2 </sub>and &#xf8;<sub>3 </sub>have been substituted into equation 3 for &#xf8;<sub>1 </sub>and &#xf8;<sub>2 </sub>respectively should be apparent. Equations 4 and 6 are related in a similar manner. In order to determine a pointer position using the camera assemblies <b>63</b> along the bottom of the touch screen <b>52</b>, the following equations are used to determine the (x<sub>0</sub>, y<sub>0</sub>) coordinates of the pointer position given the angles &#xf8;<sub>0 </sub>and &#xf8;<sub>3 </sub>for bottom left and bottom right camera assemblies:  
<maths id="MATH-US-00004" num="4">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>x</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <mi>tan</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>&#x3d5;</mi>
                <mn>3</mn>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mrow>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>0</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>3</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>7</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mtable>
        <mtr>
          <mtd>
            <mrow>
              <msub>
                <mi>y</mi>
                <mn>0</mn>
              </msub>
              <mo>=</mo>
              <mrow>
                <mfrac>
                  <mi>w</mi>
                  <mi>h</mi>
                </mfrac>
                <mo>&#xd7;</mo>
                <mfrac>
                  <mrow>
                    <mi>tan</mi>
                    <mo>&#x2061;</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>&#x3d5;</mi>
                        <mn>3</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                  <mrow>
                    <mrow>
                      <mi>tan</mi>
                      <mo>&#x2061;</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>&#x3d5;</mi>
                          <mn>0</mn>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                    <mo>+</mo>
                    <mrow>
                      <mi>tan</mi>
                      <mo>&#x2061;</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>&#x3d5;</mi>
                          <mn>3</mn>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                  </mrow>
                </mfrac>
                <mo>&#xd7;</mo>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mo>=</mo>
              <mrow>
                <mfrac>
                  <mi>w</mi>
                  <mi>h</mi>
                </mfrac>
                <mo>&#xd7;</mo>
                <msub>
                  <mi>x</mi>
                  <mn>0</mn>
                </msub>
                <mo>&#xd7;</mo>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>0</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>8</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0104" num="0103"> In order to determine a pointer position using the camera assemblies <b>63</b> along the top of the touch screen <b>52</b>, the following equations are used to determine the (x<sub>0</sub>, y<sub>0</sub>) coordinates of the pointer position given the angles &#xf8;<sub>1 </sub>and &#xf8;<sub>2 </sub>for the top left and top right camera assemblies:  
<maths id="MATH-US-00005" num="5">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>x</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <mi>tan</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>&#x3d5;</mi>
                <mn>2</mn>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
          <mrow>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>1</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>2</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>9</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mtable>
        <mtr>
          <mtd>
            <mrow>
              <msub>
                <mi>y</mi>
                <mn>0</mn>
              </msub>
              <mo>=</mo>
              <mrow>
                <mn>1</mn>
                <mo>-</mo>
                <mrow>
                  <mfrac>
                    <mi>w</mi>
                    <mi>h</mi>
                  </mfrac>
                  <mo>&#xd7;</mo>
                  <mfrac>
                    <mrow>
                      <mi>tan</mi>
                      <mo>&#x2061;</mo>
                      <mrow>
                        <mo>(</mo>
                        <msub>
                          <mi>&#x3d5;</mi>
                          <mn>2</mn>
                        </msub>
                        <mo>)</mo>
                      </mrow>
                    </mrow>
                    <mrow>
                      <mrow>
                        <mi>tan</mi>
                        <mo>&#x2061;</mo>
                        <mrow>
                          <mo>(</mo>
                          <msub>
                            <mi>&#x3d5;</mi>
                            <mn>1</mn>
                          </msub>
                          <mo>)</mo>
                        </mrow>
                      </mrow>
                      <mo>+</mo>
                      <mrow>
                        <mi>tan</mi>
                        <mo>&#x2061;</mo>
                        <mrow>
                          <mo>(</mo>
                          <msub>
                            <mi>&#x3d5;</mi>
                            <mn>2</mn>
                          </msub>
                          <mo>)</mo>
                        </mrow>
                      </mrow>
                    </mrow>
                  </mfrac>
                  <mo>&#xd7;</mo>
                  <mrow>
                    <mi>tan</mi>
                    <mo>&#x2061;</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>&#x3d5;</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mo>=</mo>
              <mrow>
                <mn>1</mn>
                <mo>-</mo>
                <mrow>
                  <mfrac>
                    <mi>w</mi>
                    <mi>h</mi>
                  </mfrac>
                  <mo>&#xd7;</mo>
                  <msub>
                    <mi>x</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>&#xd7;</mo>
                  <mrow>
                    <mi>tan</mi>
                    <mo>&#x2061;</mo>
                    <mrow>
                      <mo>(</mo>
                      <msub>
                        <mi>&#x3d5;</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>)</mo>
                    </mrow>
                  </mrow>
                </mrow>
              </mrow>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>10</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0105" num="0104"> The similarity between equations 7 and 9, i.e. equation 9=equation 7 once &#xf8;<sub>1 </sub>and &#xf8;<sub>2 </sub>have been substituted into equation 7 for &#xf8;<sub>0 </sub>and &#xf8;<sub>3 </sub>should be apparent. Equations 8 and 10 have the following relationship: equation 10=1&#x2212;equation 8 once &#xf8;<sub>1 </sub>and &#xf8;<sub>2 </sub>have been substituted into equation 8 for &#xf8;<sub>0 </sub>and &#xf8;<sub>3 </sub>respectively. </p>
<p id="p-0106" num="0105"> In order to determine a pointer position using the camera assemblies <b>63</b> across the bottom left to top right corner diagonal, the following equations are used to determine the (x<sub>0</sub>, y<sub>0</sub>) coordinates of the pointer position given the angles &#xf8;<sub>0 </sub>and &#xf8;<sub>2 </sub>for bottom left and top right camera assemblies:  
<maths id="MATH-US-00006" num="6">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>x</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <mfrac>
              <mi>h</mi>
              <mi>w</mi>
            </mfrac>
            <mo>-</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>2</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
          <mrow>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>0</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>2</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>11</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>y</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mrow>
          <mfrac>
            <mrow>
              <mn>1</mn>
              <mo>-</mo>
              <mfrac>
                <mi>w</mi>
                <mi>h</mi>
              </mfrac>
              <mo>-</mo>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
            <mrow>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>0</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
                <mi>tan</mi>
                <mo>&#x2061;</mo>
                <mrow>
                  <mo>(</mo>
                  <msub>
                    <mi>&#x3d5;</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>)</mo>
                </mrow>
              </mrow>
            </mrow>
          </mfrac>
          <mo>&#xd7;</mo>
          <mrow>
            <mi>tan</mi>
            <mo>&#x2061;</mo>
            <mrow>
              <mo>(</mo>
              <msub>
                <mi>&#x3d5;</mi>
                <mn>0</mn>
              </msub>
              <mo>)</mo>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>12</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0107" num="0106"> In order to determine a pointer position using the camera assemblies <b>63</b> across the bottom right to top left diagonal, the following equations are used to determine the (x<sub>0</sub>, y<sub>0</sub>) coordinates of the pointer position given the angles &#xf8;<sub>1 </sub>and &#xf8;<sub>3 </sub>for the bottom right and top left camera assemblies:  
<maths id="MATH-US-00007" num="7">
<math overflow="scroll">
<mtable>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>x</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mfrac>
          <mrow>
            <mfrac>
              <mi>h</mi>
              <mi>w</mi>
            </mfrac>
            <mo>-</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>3</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
          <mrow>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>1</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>3</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mfrac>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>13</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
  <mtr>
    <mtd>
      <mrow>
        <msub>
          <mi>y</mi>
          <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
            <mfrac>
              <mrow>
                <mn>1</mn>
                <mo>-</mo>
                <mfrac>
                  <mi>w</mi>
                  <mi>h</mi>
                </mfrac>
                <mo>-</mo>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>3</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
              <mrow>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>-</mo>
                <mrow>
                  <mi>tan</mi>
                  <mo>&#x2061;</mo>
                  <mrow>
                    <mo>(</mo>
                    <msub>
                      <mi>&#x3d5;</mi>
                      <mn>3</mn>
                    </msub>
                    <mo>)</mo>
                  </mrow>
                </mrow>
              </mrow>
            </mfrac>
            <mo>&#xd7;</mo>
            <mrow>
              <mi>tan</mi>
              <mo>&#x2061;</mo>
              <mrow>
                <mo>(</mo>
                <msub>
                  <mi>&#x3d5;</mi>
                  <mn>1</mn>
                </msub>
                <mo>)</mo>
              </mrow>
            </mrow>
          </mrow>
        </mrow>
      </mrow>
    </mtd>
    <mtd>
      <mrow>
        <mo>(</mo>
        <mn>14</mn>
        <mo>)</mo>
      </mrow>
    </mtd>
  </mtr>
</mtable>
</math>
</maths>
</p>
<p id="p-0108" num="0107"> The similarity between equations 11 and 13, i.e. equation 13=equation 11 once &#xb0;1 and &#xb0;3 have been substituted into equation 11 for &#xf8;<sub>0 </sub>and &#xf8;<sub>2 </sub>should be apparent. Equations 12 and 14 have the following relationship: equation 14=1&#x2212;equation 12 once &#xf8;<sub>1 </sub>and &#xf8;<sub>3 </sub>have been substituted into equation 12 for &#xf8;<sub>0 </sub>and &#xf8;<sub>2 </sub>respectively. </p>
<p id="p-0109" num="0108"> As will be appreciated, the above equations generate the coordinates x<sub>0 </sub>and y<sub>0 </sub>on a scale of [0, 1]. Therefore, any appropriate coordinate scale can be reported by multiplying x<sub>0 </sub>and y<sub>0 </sub>by the maximum X and maximum Y values respectively. </p>
<p id="p-0110" num="0109"> In the present embodiment, the DSP <b>90</b> calculates the pointer position using triangulation for each camera pair excluding the diagonal pairs. The resulting pointer positions are then averaged and the resulting pointer position coordinates are queued for transmission to the personal computer <b>56</b> via the serial port <b>98</b> and the serial line driver <b>94</b>. Since the rows of pixels of the image sensor and lens assemblies <b>80</b> that correspond to actual contacts with the touch surface <b>60</b> are known, any Z-position in a PIP that does not correspond with one of these rows is by definition a pointer hover event. </p>
<p id="p-0111" num="0110"> If desired, pointer velocity and angle can be calculated by the DSP <b>90</b> as shown in <figref idref="DRAWINGS">FIG. 18</figref>. The velocity of the pointer is calculated by examining the changes in the Z-position (or X-intercept) of the pointer in successive PIPs and knowing the camera frame rate. For example, if the camera frame rate is 200 frames per second and the Z-position changes by 1 pixel per frame, the pointer velocity is 200 pixels per second. </p>
<p id="p-0112" num="0111"> The angle of the pointer can be determined due to the fact that the PIP includes the X-intercept at pixel rows 0 and 19 of the median line. Since the X distance (the difference between X-intercepts) and the Y distance (the number of pixel rows) are known, all of the information necessary to calculate the pointer angle is available. </p>
<p id="p-0113" num="0112"> The present invention provides advantages in that the passive touch system <b>50</b> does not suffer parallax and/or image distortion problems due to the fact that a glass or other transparent overlay over a computer or video display is not required. In addition, the present passive touch system <b>50</b> allows both pointer contact and pointer hover over the touch surface <b>60</b> to be detected by using two-dimensional image sensor and lens assemblies <b>80</b> in the plane of the touch surface <b>60</b>. Pointer contact with the touch surface <b>60</b> is defined only when the pointer is in very close proximity of the touch surface. The present invention also provides advantages in that the pointer position with respect to the touch surface is not restricted since the image sensor and lens assemblies <b>80</b> look along the plane of the touch surface <b>60</b>. </p>
<p id="p-0114" num="0113"> With respect to resolution, the resolution of the passive touch system is a function of the distances of the pointer with respect to the image sensor and lens assemblies <b>80</b>, the number of pixel elements in the image sensor and lens assemblies and the fields of view of the image sensor and lens assemblies. Since image sensor and lens assemblies are available with pixel elements that range in number from tens of thousand to many millions and since the number of pixel elements in image sensors and lens assemblies of this nature is only expected to increase, the resolution of the present passive touch system <b>50</b> is high. </p>
<p id="p-0115" num="0114"> The passive touch system <b>50</b> also provides advantages in that alignment is automatically corrected since only pixel subsets of images that include the touch surface and the pointer are processed. In addition, the present passive touch system allows for very fast acquisition of image data since the image sensor and lens assemblies can be triggered to capture images at rates exceeding two hundred frames per second. </p>
<p id="p-0116" num="0115"> The present passive touch system <b>50</b> is scaleable and can include a touch surface <b>60</b> of arbitrary size. When used in conjunction with a projected computer image, the number of pixels of the image sensor and lens assemblies should be proportional to the number of pixels being displayed on the touch surface <b>60</b>. For example, if a projected computer image is 1024&#xd7;768 pixels, the size of the projected image is not be of concern provided the image sensor and lens assemblies <b>80</b> are able to resolve the (x,y) coordinates with sufficient accuracy with respect to the displayed pixels. </p>
<p id="p-0117" num="0116"> Although the passive touch system <b>50</b> is shown including camera assemblies <b>63</b> associated with each corner of the touch screen <b>52</b>, those of skill in the art will appreciate that only two camera assemblies are required. In this case, the fields of view of the image sensor and lens assemblies are preferably selected so that the entire touch surface <b>60</b> is encompassed since the locations of pointer contacts are determined only when they occur within the overlapping fields of view of the camera assemblies <b>63</b>. </p>
<p id="p-0118" num="0117"> Also, although the passive touch system <b>50</b> is described as including a projector to display the computer display output onto the touch surface <b>60</b>, this is not required. No information need be displayed on the touch surface. </p>
<p id="p-0119" num="0118"> Although a preferred embodiment of the present invention has been described, those of skill in the art will appreciate that variations and modifications may be made without departing from the spirit and scope thereof as defined by the appended claims. </p>
<?detailed-description description="Detailed Description" end="tail"?>
</description>
<us-math idrefs="MATH-US-00001" nb-file="US20070002028A1-20070104-M00001.NB">
<img id="EMI-M00001" he="14.14mm" wi="76.20mm" file="US20070002028A1-20070104-M00001.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00002" nb-file="US20070002028A1-20070104-M00002.NB">
<img id="EMI-M00002" he="15.16mm" wi="76.20mm" file="US20070002028A1-20070104-M00002.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00003" nb-file="US20070002028A1-20070104-M00003.NB">
<img id="EMI-M00003" he="15.16mm" wi="76.20mm" file="US20070002028A1-20070104-M00003.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00004" nb-file="US20070002028A1-20070104-M00004.NB">
<img id="EMI-M00004" he="21.17mm" wi="76.20mm" file="US20070002028A1-20070104-M00004.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00005" nb-file="US20070002028A1-20070104-M00005.NB">
<img id="EMI-M00005" he="21.17mm" wi="76.20mm" file="US20070002028A1-20070104-M00005.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00006" nb-file="US20070002028A1-20070104-M00006.NB">
<img id="EMI-M00006" he="20.15mm" wi="76.20mm" file="US20070002028A1-20070104-M00006.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-math idrefs="MATH-US-00007" nb-file="US20070002028A1-20070104-M00007.NB">
<img id="EMI-M00007" he="20.15mm" wi="76.20mm" file="US20070002028A1-20070104-M00007.TIF" alt="embedded image" img-content="math" img-format="tif"/>
</us-math>
<us-claim-statement>What is claimed is: </us-claim-statement>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text><b>1</b>. An imaging assembly comprising: 
<claim-text>a substantially rectangular frame to surround a region of interest in front of a display surface; and </claim-text>
<claim-text>a plurality of digital cameras mounted adjacent at least three comers of said frame, said digital cameras being oriented to capture overlapping images of said region of interest. </claim-text>
</claim-text>
 </claim>
<claim id="CLM-00002" num="00002">
<claim-text><b>2</b>. An imaging assembly according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each said digital camera comprises a CMOS digital camera. </claim-text>
 </claim>
<claim id="CLM-00003" num="00003">
<claim-text><b>3</b>. An imaging assembly according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein each digital camera has a selectable pixel array. </claim-text>
 </claim>
<claim id="CLM-00004" num="00004">
<claim-text><b>4</b>. An imaging assembly according to <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein said digital cameras are oriented so that the field of view of each digital camera extends beyond a peripheral edge of said frame. </claim-text>
 </claim>
<claim id="CLM-00005" num="00005">
<claim-text><b>5</b>. An imaging assembly according to <claim-ref idref="CLM-00004">claim 4</claim-ref>, further including a processor associated with each of said digital cameras, each digital camera and associated processor being mounted on a common board. </claim-text>
 </claim>
<claim id="CLM-00006" num="00006">
<claim-text><b>6</b>. An imaging assembly according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein a subset of pixels in the selectable pixel array of each digital camera provides pixel data to said associated processor. </claim-text>
 </claim>
<claim id="CLM-00007" num="00007">
<claim-text><b>7</b>. An imaging assembly according to <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein each pixel subset includes contiguous rows of pixels. </claim-text>
 </claim>
<claim id="CLM-00008" num="00008">
<claim-text><b>8</b>. An imaging assembly according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the pixel subset of each digital camera is aligned so that the pixel subset looks along a plane substantially coplanar to said display surface. </claim-text>
 </claim>
<claim id="CLM-00009" num="00009">
<claim-text><b>9</b>. An imaging assembly according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the row of pixels in the pixel subset of each digital camera, that acquires pixel data corresponding to a tip of said pointer within said region of interest, is determined to enable said processor to detect pointer contact and pointer hover over said display surface.</claim-text>
 </claim>
</claims>
</us-patent-application>
